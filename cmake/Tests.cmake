# SPDX-FileCopyrightText: Copyright (c) 2025 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
# SPDX-License-Identifier: Apache-2.0
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

function(enable_coverage project_name)
    if(CMAKE_CXX_COMPILER_ID STREQUAL "GNU" OR CMAKE_CXX_COMPILER_ID MATCHES ".*Clang")
        # Apply coverage flags only to C++ and C files, not CUDA files
        target_compile_options(
            ${project_name} INTERFACE $<$<COMPILE_LANGUAGE:CXX>:--coverage -O0 -g>
                                      $<$<COMPILE_LANGUAGE:C>:--coverage -O0 -g>)
        target_link_libraries(${project_name} INTERFACE --coverage)
    endif()
endfunction()

# cmake-format: off
# Function to create coverage report targets
function(setup_coverage_targets)
  # Check if coverage is enabled
  if(NOT ENABLE_COVERAGE)
    return()
  endif()

  # Find gcovr tool
  find_program(GCOVR_PATH gcovr)
  if(NOT GCOVR_PATH)
    message(
      SEND_ERROR "gcovr not found! Coverage report targets cannot be created.")
    return()
  endif()

  message(STATUS "gcovr found: ${GCOVR_PATH}")
  message(STATUS "Creating coverage report targets...")

  # Create output directory
  set(COVERAGE_OUTPUT_DIR "${CMAKE_BINARY_DIR}/coverage")
  file(MAKE_DIRECTORY "${COVERAGE_OUTPUT_DIR}")

  # Create HTML coverage report target
  add_custom_target(
    coverage
    COMMAND ${CMAKE_COMMAND} -E echo "If the test report is empty, make sure you've run tests first with ctest"
    COMMAND ${CMAKE_COMMAND} -E echo "Generating HTML coverage report..."
    COMMAND ${GCOVR_PATH} --config ${CMAKE_SOURCE_DIR}/tools/gcovr.cfg --html-details ${CMAKE_BINARY_DIR}/coverage/index.html --cobertura ${CMAKE_BINARY_DIR}/cobertura.xml --gcov-executable "llvm-cov gcov" ${CMAKE_BINARY_DIR}
    WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
    COMMENT "Generating HTML coverage report"
    VERBATIM)

  # Print usage information
  message(STATUS "Coverage target created:")
  message(STATUS "  - coverage: Generate HTML and XML coverage reports")
  message(STATUS "")
  message(
    STATUS "Coverage reports will be generated in: ${COVERAGE_OUTPUT_DIR}")
  message(STATUS "Usage:")
  message(STATUS "  1. Run tests: ctest --preset <your-preset>")
  message(STATUS "  2. Generate coverage: cmake --build build -t coverage")

endfunction()
# cmake-format: on

# Adds standard version and help flag tests for executables
function(add_version_and_help_tests target_name)
    # Add help flag test
    add_test(NAME ${target_name}.has_help COMMAND $<TARGET_FILE:${target_name}> --help)
    label_parallel(${target_name}.has_help)

    # Add version flag test
    add_test(NAME ${target_name}.version_matches COMMAND $<TARGET_FILE:${target_name}> --version)
    label_parallel(${target_name}.version_matches)

    # Escape dots in PROJECT_VERSION for regex matching
    string(REPLACE "." "\\." PROJECT_VERSION_ESCAPED "${PROJECT_VERSION}")

    # Configure version test to validate output matches project version
    set_tests_properties(${target_name}.version_matches PROPERTIES PASS_REGULAR_EXPRESSION
                                                                   "${PROJECT_VERSION_ESCAPED}")
endfunction()

# Labels tests that require a physical NIC
#
# This includes tests that use DPDK, DOCA, or any networking hardware.
# Tests with this label can be excluded when running on systems without NICs.
# Appends to existing labels if present.
#
# Arguments:
#   test_name - Name of the test to label
function(label_test_requires_nic test_name)
    get_test_property(${test_name} LABELS existing_labels)
    if(existing_labels)
        set_tests_properties(${test_name} PROPERTIES LABELS "${existing_labels};requires_nic")
    else()
        set_tests_properties(${test_name} PROPERTIES LABELS "requires_nic")
    endif()
endfunction()

# Labels tests that are integration tests
#
# Integration tests typically depend on external components like:
# - FAPI capture files generated by orchestrate + testmac + fapi_sample
# - RU emulator for end-to-end testing
# Tests with this label can be excluded for fast unit-only test runs.
# Appends to existing labels if present.
#
# Arguments:
#   test_name - Name of the test to label
function(label_integration_test test_name)
    get_test_property(${test_name} LABELS existing_labels)
    if(existing_labels)
        set_tests_properties(${test_name} PROPERTIES LABELS "${existing_labels};integration")
    else()
        set_tests_properties(${test_name} PROPERTIES LABELS "integration")
    endif()
endfunction()

# Labels tests that require real-time scheduling
#
# Real-time tests use SCHED_FIFO scheduling policy and require:
# - CAP_SYS_NICE capability to set real-time priority
# - Proper system configuration for real-time performance
# Tests with this label can be excluded when running without RT capabilities.
# Appends to existing labels if present.
#
# Arguments:
#   test_name - Name of the test to label
function(label_real_time test_name)
    get_test_property(${test_name} LABELS existing_labels)
    if(existing_labels)
        set_tests_properties(${test_name} PROPERTIES LABELS "${existing_labels};real_time")
    else()
        set_tests_properties(${test_name} PROPERTIES LABELS "real_time")
    endif()
endfunction()

# Labels tests that can run in parallel
#
# Parallel tests are safe to run concurrently with other tests without
# requiring exclusive system resources or real-time scheduling.
# These are typically unit tests and non-real-time integration tests.
# Appends to existing labels if present.
#
# Arguments:
#   test_name - Name of the test to label
function(label_parallel test_name)
    get_test_property(${test_name} LABELS existing_labels)
    if(existing_labels)
        set_tests_properties(${test_name} PROPERTIES LABELS "${existing_labels};parallel")
    else()
        set_tests_properties(${test_name} PROPERTIES LABELS "parallel")
    endif()
endfunction()
